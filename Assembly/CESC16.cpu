#ifndef _RULEDEF
#define _RULEDEF
; Include ruledef file only once

#define OS_RAM_SZ 0x100     ; 256 bytes
#define CALL_GATE_ADDR 0    ; todo

#subruledef REG {
    zero => 0x0
    sp   => 0x1
    t0   => 0x2
    t1   => 0x3
    t2   => 0x4
    t3   => 0x5
    t4   => 0x6
    v0   => 0x7
    a0   => 0x8
    a1   => 0x9
    a2   => 0xA
    s0   => 0xB
    s1   => 0xC
    s2   => 0xD
    s3   => 0xE
    s4   => 0xF
}
#subruledef ALU_OP {
    and  => 0b001
    or   => 0b010
    xor  => 0b011
    add  => 0b100
    sub  => 0b101
    addc => 0b110
    subb => 0b111
}
#subruledef JUMP {
    ; Most of the x86 jump conditions
    jmp  => 0b0000
    jz   => 0b0001
    jnz  => 0b0010
    jc   => 0b0011
    jnc  => 0b0100
    jo   => 0b0101
    jno  => 0b0110
    js   => 0b0111
    jns  => 0b1000
    jbe  => 0b1001
    ja   => 0b1010
    jl   => 0b1011
    jle  => 0b1100
    jg   => 0b1101
    jge  => 0b1110
    
    ; Macros
    je   => 0b0001   ; jz
    jne  => 0b0010   ; jnz
    jb   => 0b0011   ; jc
    jnae => 0b0011   ; jc
    jnb  => 0b0100   ; jnc
    jae  => 0b0100   ; jnc
    jna  => 0b1001   ; jbe
    jnbe => 0b1010   ; ja
    jnge => 0b1011   ; jl
    jng  => 0b1100   ; jle
    jnle => 0b1101   ; jg
    jnl  => 0b1110   ; jge
}
#subruledef PEEK_OPTIONS {
    {num: u1} => num ; 1 or 0
    Up  =>  1
    Low =>  0
    Op  =>  1
    Arg =>  0
}
#subruledef JMP_ADDR {
    #ifdef RAM_PROGRAM
        skip({Off: i16})   =>  pc+(Off+1)*2 ; Skips a number of instructions (RAM)
    #else 
        skip({Off: i16})   =>  pc+Off+1  ; Skips a number of instructions (ROM)
    #endif
    {Imm: u16}   =>   Imm
}

; Instruction definitions needed for macros
#define _MOV_REG(rD, rA)            0x00 @ rD`4 @ rA`4 @ 0x0000
#define _ALU_REG(op, rD, rA, rB)    0b00000 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4
#define _ALU_IMM(op, rD, rA, Imm)   0b00001 @ op`3 @ rD`4 @ rA`4 @ Imm
#define _ALU_DIR(op, rD, rA, Addr)  0b01000 @ op`3 @ rD`4 @ rA`4 @ Addr
#define _ALU_IND(op, rD, rA, rB)    0b01001 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4
#define _ALU_IDX(op, rD, rA, Imm)   0b01010 @ op`3 @ rD`4 @ rA`4 @ Imm

#define _MOV_IDX_A(rD, rA, Imm)     0x50 @ rD`4 @ rA`4 @ Imm
#define _MOV_IDX_D(rB, rA, Imm)     0x70 @ rB`4 @ rA`4 @ Imm

#define _MOVB(rD, rA, Imm)          0x80 @ rD`4 @ rA`4 @ Imm
#define _SWAP(rD, rA, Imm)          0x81 @ rD`4 @ rA`4 @ Imm
#define _PEEK(rD, rA, Imm, W)       0b1000001 @ W`1 @ rD`4 @ rA`4 @ Imm


#ruledef INSTRUCTIONS {
    ; ALU
    mov {rD: REG}, {rA: REG} => _MOV_REG(rD, rA)
    {op: ALU_OP} {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(op, rD, rA, rB)

    mov {rD: REG}, {Imm: i16} => 0x08 @ rD`4 @ 0x0 @ Imm
    {op: ALU_OP} {rD: REG}, {rA: REG}, {Imm: i16} => _ALU_IMM(op, rD, rA, Imm)
    
    mov {rD: REG}, [{Addr: u16}] => 0x40 @ rD`4 @ 0x0 @ Addr
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{Addr: u16}] => _ALU_DIR(op, rD, rA, Addr)
    
    mov {rD: REG}, [{rB: REG}] => 0x48 @ rD`4 @ 0x0000 @ rB`4
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{rB: REG}] => _ALU_IND(op, rD, rA, rB)

    mov {rD: REG}, [{rA: REG}+{Imm: i16}]   =>  _MOV_IDX_A(rD, rA, Imm)
    {op: ALU_OP} {rD: REG}, [{rA: REG}+{Imm: i16}] => _ALU_IDX(op, rD, rA, Imm)

    mov [{Addr: u16}], {rA: REG} => 0x600 @ rA`4 @ Addr
    {op: ALU_OP} [{Addr: u16}], {rA: REG} => 0b01100 @ op`3 @ 0x0 @ rA`4 @ Addr
    
    mov [{rA: REG}], {rB: REG} => 0x680 @ rA`4 @ 0x000 @ rB`4
    {op: ALU_OP} [{rA: REG}], {rB: REG} => 0b01101 @ op`3 @ 0x0 @ rA`4 @ 0x000 @ rB`4

    mov [{rA: REG}+{Imm: i16}], {rB: REG}   =>  _MOV_IDX_D(rB, rA, Imm)
    {op: ALU_OP} [{rA: REG}+{Imm: i16}], {rB: REG} => 0b01110 @ op`3 @ rB`4 @ rA`4 @ Imm
    
    sll {rD: REG}, {rA: REG}, {Imm: u4} => 0x1 @ Imm @ rD`4 @ rA`4 @ 0x0000
    srl {rD: REG}, {rA: REG}, {Imm: u4} => 0x2 @ Imm @ rD`4 @ rA`4 @ 0x0000
    sra {rD: REG}, {rA: REG}, {Imm: u4} => 0x3 @ Imm @ rD`4 @ rA`4 @ 0x0000
    
    ; Memory
    movb {rD: REG}, [{rA: REG}+{Imm: i16}]  => _MOVB(rD, rA, Imm)
    swap {rD: REG}, [{rA: REG}+{Imm: i16}]  => _SWAP(rD, rA, Imm)
    peek {rD: REG}, [{rA: REG}+{Imm: i16}], {W: PEEK_OPTIONS} => _PEEK(rD, rA, Imm, W)
    
    push {rB: REG}  => 0x8401000 @ rB`4
    push {Imm: i16} => 0x8501 @ Imm
    pushf           => 0x86010000

    pop  {rD: REG}  => 0x87 @ rD`4 @ 0x10000
    popf            => 0x88010000
    
    ; Jumps
    {jmp: JUMP} {rA: REG}        => 0b1100 @ jmp`4 @ 0x0 @ rA`4 @ 0x0000
    {jmp: JUMP} {Addr: JMP_ADDR} => 0b1101 @ jmp`4 @ 0x00 @ Addr`16
    
    call {rB: REG}            => 0xE001 @ 0x000 @ rB`4
    call {Addr: JMP_ADDR}     => 0xE101 @ Addr`16
    syscall {rB: REG}         => 0xE201 @ 0x000 @ rB`4
    syscall {Addr: JMP_ADDR}  => 0xE301 @ Addr`16
    enter {rB: REG}           => 0xE401 @ 0x000 @ rB`4
    enter {Addr: JMP_ADDR}    => 0xE501 @ Addr`16
    ret     => 0xE6010000
    sysret  => 0xE7010000
    exit    => 0xE8010000
}

#ruledef MACROS {
    movf {rD: REG}, {rA: REG}     => _ALU_REG(0b100, rD, 0, rA)     ; Expands to: add rD, zero, rA
    movf {rD: REG}, [{Addr: u16}] => _ALU_DIR(0b100, rD, 0, Addr)   ; Expands to: add rD, zero, [Addr16]
    movf {rD: REG}, {Imm: i16}    => _ALU_IMM(0b100, rD, 0, Imm)    ; Expands to: add rD, zero, Imm16
    movf {rD: REG}, [{rA: REG}]   => _ALU_IND(0b100, rD, 0, rA)     ; Expands to: add rD, zero, [rA]

    movb {rD: REG}, [{Imm: i16}]            => _MOVB(rD, 0, Imm)    ; Expands to: movb rD, [zero+Imm16]
    movb {rD: REG}, [{rA: REG}]             => _MOVB(rD, rA, 0)     ; Expands to: movb rD, [rA+0]
    movb [{rA: REG}+{Imm: i16}], {rB: REG}  => _MOV_IDX_D(rB, rA, Imm)  ; Same as regular store
    movb [{Imm: i16}], {rB: REG}            => _MOV_IDX_D(rB, 0, Imm)
    movb [{rA: REG}], {rB: REG}             => _MOV_IDX_D(rB, rA, 0)
    
    not  {rD: REG}, {rA: REG}   =>  _ALU_IMM(0b011, rD, rA, 0xFFFF) ; Expands to: xor rD, rA, 0xFFFF
    nand {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b001, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: and rD, rA, rB; xor rD, rD, 0xFFFF
    nor  {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b010, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: or rD, rA, rB; xor rD, rD, 0xFFFF
    xnor {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b011, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: xor rD, rA, rB; xor rD, rD, 0xFFFF
    
    sllc {rD: REG}, {rA: REG}   =>  _ALU_REG(0b110, rD, rA, rA)  ; Expands to: addc rD, rA, rA
    
    ; lw   {rD: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_A(rD, rA, Imm)
    ; sw   {rB: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_D(rB, rA, Imm)
    ; lb   {rD: REG}, {Imm: i16}({rA: REG})   => _MOVB(rD, rA, Imm)
    ; lbu  {rD: REG}, {Imm: i16}({rA: REG})   => _MOVB(rD, rA, Imm) @ _ALU_IMM(0b001, rD, rD, 0x00FF) ; Expands to: lb rD, Imm16(rA); and rD, rD, 0x00FF
    ; sb   {rB: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_D(rB, rA, Imm)  ; Expands to: sw rD, Imm16(rA)
    
    ; No-Temp Swap. Expands to: xor rA, rA, rB; xor rB, rA, rB; xor rA, rA, rB
    swap {rA: REG}, {rA: REG}       => _ALU_REG(0b011, rA, rA, rB) @  _ALU_REG(0b011, rB, rA, rB) @ _ALU_REG(0b011, rA, rA, rB)
    swap {rD: REG}, [{Imm: i16}]    => _SWAP(rD, 0, Imm)
    swap {rD: REG}, [{rA: REG}]     => _SWAP(rD, rA, 0x0000)
    peek {rD: REG}, [{Imm: i16}], {W: PEEK_OPTIONS} => _PEEK(rD, 0, Imm, W)
    peek {rD: REG}, [{rA: REG}],  {W: PEEK_OPTIONS} => _PEEK(rD, rA, 0x0000, W)
    
    cmp {rA: REG}, {rB: REG}  => _ALU_REG(0b101, 0, rA, rB)   ; Expands to: sub zero, rA, rB
    cmp {rA: REG}, {Imm: i16} => _ALU_IMM(0b101, 0, rA, Imm)  ; Expands to: sub zero, rA, Imm
    
    mask {rA: REG}, {rB: REG}     => _ALU_REG(0b001, 0, rA, rB)   ; Expands to: and zero, rA, rB
    mask {rA: REG}, {Imm: i16}    => _ALU_IMM(0b001, 0, rA, Imm)  ; Expands to: and zero, rA, Imm
    mask {rA: REG}, [{Addr: u16}] => _ALU_DIR(0b001, 0, rA, Addr) ; Expands to: and zero, rA, [Addr]
    mask {rA: REG}, [{rB: REG}]   => _ALU_IND(0b001, 0, rA, rB)   ; Expands to: and zero, rA, [rB]
    
    test {rA: REG}              => _ALU_REG(0b100, 0, 0, rA)    ; Expands to: add zero, zero, rA
    test [{Addr: u16}]          => _ALU_DIR(0b100, 0, 0, Addr)  ; Expands to: add zero, zero, [Addr16]
    test [{rA: REG}]            => _ALU_IND(0b100, 0, 0, rA)    ; Expands to: add zero, zero, [rA]
    test [{rA: REG}+{Imm: i16}] => _ALU_IDX(0b100, 0, rA, Imm)  ; Expands to: add zero, [rA+Imm16]
    
    clrf => _ALU_IMM(0b100, 0, 0, 0x0001)    ; Expands to: add zero, zero, 0x0001
    
    nop => _MOV_REG(0, 0)   ; Encoded as 0x00000000, Expands to: mov zero, zero
}

; Utilities
#ifdef RAM_PROGRAM
    #define sizeof(Begin) (pc - Begin)    ; Returns the data size between Begin and the current spot (RAM)
#else 
    #define sizeof(Begin) (pc - Begin)*2  ; Returns the data size between Begin and the current spot (ROM)
#endif

#define progmem(Begin, End) #res (End - Begin)*2    ; Reserve space to fit program memory between Begin and End
#define str(text)   #d text, "\0"       ; Remember to use "#align 32" afterwards

; Banks
#ifndef RAM_PROGRAM
; BANKS FOR OS (ROM)
#bankdef program {
    #addr 0
    #size 0x10000   ; 64k
    #outp 0
    #bits 32
}
#bankdef data {
    #addr 0
    #size 0x10000   ; 64k
    #bits 16
}

#else
; BANKS FOR USER PROGRAMS (RAM)
#bankdef program_labels {
    #addr 0
    #size 0x10000   ; 64k
    #bits 32
}
#bankdef mem {
    #addr OS_RAM_SZ ; Reserve memory for OS global variables
    #size 0x10000   ; 64k
    #bits 16
    #outp 0
}
#endif

#ifdef RAM_PROGRAM
    #include "OS/symbols.inc"
#endif

; End ruledef
#endif
