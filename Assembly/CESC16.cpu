#ifndef _RULEDEF
#define _RULEDEF
; Include ruledef file only once

#subruledef REG {
    zero => 0x0
    sp   => 0x1
    t0   => 0x2
    t1   => 0x3
    t2   => 0x4
    t3   => 0x5
    t4   => 0x6
    v0   => 0x7
    a0   => 0x8
    a1   => 0x9
    a2   => 0xA
    s0   => 0xB
    s1   => 0xC
    s2   => 0xD
    s3   => 0xE
    s4   => 0xF
}
#subruledef ALU_OP {
    and  => 0b001
    or   => 0b010
    xor  => 0b011
    add  => 0b100
    sub  => 0b101
    addc => 0b110
    subb => 0b111
}
#subruledef JUMP {
    jmp  => 0b000
    jz   => 0b001
    jnz  => 0b010
    jc   => 0b011
    jnc  => 0b100
    jleu => 0b101
    jlt  => 0b110
    jle  => 0b111
    
    ; Macros
    jeq  => 0b001
    jne  => 0b010
    jnb  => 0b011
    jb   => 0b100
    jltu => 0b100
}
#subruledef PEEK_OPTIONS {
    {num: u1} => num ; 1 or 0
    Up  =>  1
    Low =>  0
    Op  =>  1
    Arg =>  0
}
#subruledef JMP_ADDR {
    skip({Off: i16})   =>  pc+Off+1  ; Skips a number of instructions
    {Imm: u16}   =>   Imm
}

; Instruction definitions needed for macros
#define _MOV_REG(rD, rA)            0x00 @ rD`4 @ rA`4 @ 0x0000
#define _ALU_REG(op, rD, rA, rB)    0b00000 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4
#define _ALU_IMM(op, rD, rA, Imm)   0b00001 @ op`3 @ rD`4 @ rA`4 @ Imm
#define _ALU_DIR(op, rD, rA, Addr)  0b01000 @ op`3 @ rD`4 @ rA`4 @ Addr
#define _ALU_IND(op, rD, rA, rB)    0b01001 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4
#define _ALU_IDX(op, rD, rA, Imm)   0b01010 @ op`3 @ rD`4 @ rA`4 @ Imm

#define _MOV_IDX_A(rD, rA, Imm)     0x50 @ rD`4 @ rA`4 @ Imm
#define _MOV_IDX_D(rB, rA, Imm)     0x70 @ rB`4 @ rA`4 @ Imm

#define _MOVB(rD, rA, Imm)          0x80 @ rD`4 @ rA`4 @ Imm
#define _SWAP(rD, rA, Imm)          0x81 @ rD`4 @ rA`4 @ Imm


#ruledef INSTRUCTIONS {
    ; ALU
    mov {rD: REG}, {rA: REG} => _MOV_REG(rD, rA)
    {op: ALU_OP} {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(op, rD, rA, rB)

    mov {rD: REG}, {Imm: i16} => 0x08 @ rD`4 @ 0x0 @ Imm
    {op: ALU_OP} {rD: REG}, {rA: REG}, {Imm: i16} => _ALU_IMM(op, rD, rA, Imm)
    
    mov {rD: REG}, [{Addr: u16}] => 0x40 @ rD`4 @ 0x0 @ Addr
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{Addr: u16}] => _ALU_DIR(op, rD, rA, Addr)
    
    mov {rD: REG}, [{rB: REG}] => 0x48 @ rD`4 @ 0x0000 @ rB`4
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{rB: REG}] => _ALU_IND(op, rD, rA, rB)

    mov {rD: REG}, [{rA: REG}+{Imm: i16}]   =>  _MOV_IDX_A(rD, rA, Imm)
    {op: ALU_OP} {rD: REG}, [{rA: REG}+{Imm: i16}] => _ALU_IDX(op, rD, rA, Imm)

    mov [{Addr: u16}], {rA: REG} => 0x600 @ rA`4 @ Addr
    {op: ALU_OP} [{Addr: u16}], {rA: REG} => 0b01100 @ op`3 @ 0x0 @ rA`4 @ Addr
    
    mov [{rA: REG}], {rB: REG} => 0x680 @ rA`4 @ 0x000 @ rB`4
    {op: ALU_OP} [{rA: REG}], {rB: REG} => 0b01101 @ op`3 @ 0x0 @ rA`4 @ 0x000 @ rB`4

    mov [{rA: REG}+{Imm: i16}], {rB: REG}   =>  _MOV_IDX_D(rB, rA, Imm)
    {op: ALU_OP} [{rA: REG}+{Imm: i16}], {rB: REG} => 0b01110 @ op`3 @ rB`4 @ rA`4 @ Imm
    
    sll {rD: REG}, {rA: REG}, {Imm: u4} => 0x1 @ Imm @ rD`4 @ rA`4 @ 0x0000
    srl {rD: REG}, {rA: REG}, {Imm: u4} => 0x2 @ Imm @ rD`4 @ rA`4 @ 0x0000
    sra {rD: REG}, {rA: REG}, {Imm: u4} => 0x3 @ Imm @ rD`4 @ rA`4 @ 0x0000
    
    ; Memory
    movb {rD: REG}, [{rA: REG}+{Imm: i16}]  => _MOVB(rD, rA, Imm)
    swap {rD: REG}, [{rA: REG}+{Imm: i16}]  => _SWAP(rD, rA, Imm)
    peek {rD: REG}, [{rA: REG}+{Imm: i16}], {W: PEEK_OPTIONS} => 0b1000001 @ W`1 @ rD`4 @ rA`4 @ Imm
    
    push {rB: REG}  => 0x8401000 @ rB`4
    push {Imm: i16} => 0x8501 @ Imm
    pushf           => 0x86010000

    pop  {rD: REG}  => 0x87 @ rD`4 @ 0x10000
    popf            => 0x88010000
    
    ; Jumps
    {jmp: JUMP} {rA: REG}        => 0b11000 @ jmp`3 @ 0x0 @ rA`4 @ 0x0000
    {jmp: JUMP} {Addr: JMP_ADDR} => 0b11001 @ jmp`3 @ 0x00 @ Addr`16
    
    call {rB: REG}            => 0xD001 @ 0x000 @ rB`4
    call {Addr: JMP_ADDR}     => 0xD101 @ Addr`16
    syscall {rB: REG}         => 0xD201 @ 0x000 @ rB`4
    syscall {Addr: JMP_ADDR}  => 0xD301 @ Addr`16
    enter {rB: REG}           => 0xD401 @ 0x000 @ rB`4
    enter {Addr: JMP_ADDR}    => 0xD501 @ Addr`16
    ret     => 0xD6010000
    sysret  => 0xD7010000
    exit    => 0xD8010000
}

#ruledef MACROS {
    movf {rD: REG}, {rA: REG}     => _ALU_REG(0b100, rD, 0, rA)     ; Expands to: add rD, zero, rA
    movf {rD: REG}, [{Addr: u16}] => _ALU_DIR(0b100, rD, 0, Addr)   ; Expands to: add rD, zero, [Addr16]
    movf {rD: REG}, {Imm: i16}    => _ALU_IMM(0b100, rD, 0, Imm)    ; Expands to: add rD, zero, Imm16
    movf {rD: REG}, [{rA: REG}]   => _ALU_IND(0b100, rD, 0, rA)     ; Expands to: add rD, zero, [rA]

    movb {rD: REG}, [{Imm: i16}]            => _MOVB(rD, 0, Imm)    ; Expands to: movb rD, [zero+Imm16]
    movb {rD: REG}, [{rA: REG}]             => _MOVB(rD, rA, 0)     ; Expands to: movb rD, [rA+0]
    movb [{rA: REG}+{Imm: i16}], {rB: REG}  => _MOV_IDX_D(rB, rA, Imm)  ; Same as regular store
    movb [{Imm: i16}], {rB: REG}            => _MOV_IDX_D(rB, 0, Imm)
    movb [{rA: REG}], {rB: REG}             => _MOV_IDX_D(rB, rA, 0)
    
    not  {rD: REG}, {rA: REG}   =>  _ALU_IMM(0b011, rD, rA, 0xFFFF) ; Expands to: xor rD, rA, 0xFFFF
    nand {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b001, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: and rD, rA, rB; xor rD, rD, 0xFFFF
    nor  {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b010, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: or rD, rA, rB; xor rD, rD, 0xFFFF
    xnor {rD: REG}, {rA: REG}, {rB: REG} => _ALU_REG(0b011, rD, rA, rB) @ _ALU_IMM(0b011, rD, rD, 0xFFFF) ; Expands to: xor rD, rA, rB; xor rD, rD, 0xFFFF
    
    sllc {rD: REG}, {rA: REG}   =>  _ALU_REG(0b110, rD, rA, rA)  ; Expands to: addc rD, rA, rA
    
    lw   {rD: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_A(rD, rA, Imm)
    sw   {rB: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_D(rB, rA, Imm)
    lb   {rD: REG}, {Imm: i16}({rA: REG})   => _MOVB(rD, rA, Imm)
    lbu  {rD: REG}, {Imm: i16}({rA: REG})   => _MOVB(rD, rA, Imm) @ _ALU_IMM(0b001, rD, rD, 0x00FF) ; Expands to: lb rD, Imm16(rA); and rD, rD, 0x00FF
    sb   {rB: REG}, {Imm: i16}({rA: REG})   => _MOV_IDX_D(rB, rA, Imm)  ; Expands to: sw rD, Imm16(rA)
    
    swap {rD: REG}, [{Imm: i16}]    => _SWAP(rD, 0, Imm)
    swap {rD: REG}, [{rA: REG}]     => _SWAP(rD, rA, 0x0000)
    
    cmp {rA: REG}, {rB: REG}  => _ALU_REG(0b101, 0, rA, rB)   ; Expands to: sub zero, rA, rB
    cmp {rA: REG}, {Imm: i16} => _ALU_IMM(0b101, 0, rA, Imm)  ; Expands to: sub zero, rA, Imm
    
    mask {rA: REG}, {rB: REG}     => _ALU_REG(0b001, 0, rA, rB)   ; Expands to: and zero, rA, rB
    mask {rA: REG}, {Imm: i16}    => _ALU_IMM(0b001, 0, rA, Imm)  ; Expands to: and zero, rA, Imm
    mask {rA: REG}, [{Addr: u16}] => _ALU_DIR(0b001, 0, rA, Addr) ; Expands to: and zero, rA, [Addr]
    mask {rA: REG}, [{rB: REG}]   => _ALU_IND(0b001, 0, rA, rB)   ; Expands to: and zero, rA, [rB]
    
    test {rA: REG}              => _ALU_REG(0b100, 0, 0, rA)    ; Expands to: add zero, zero, rA
    test [{Addr: u16}]          => _ALU_DIR(0b100, 0, 0, Addr)  ; Expands to: add zero, zero, [Addr16]
    test [{rA: REG}]            => _ALU_IND(0b100, 0, 0, rA)    ; Expands to: add zero, zero, [rA]
    test [{rA: REG}+{Imm: i16}] => _ALU_IDX(0b100, 0, rA, Imm)  ; Expands to: add zero, [rA+Imm16]
    
    clrf => _ALU_IMM(0b100, 0, 0, 0x0001)    ; Expands to: add zero, zero, 0x0001
    
    nop => _MOV_REG(0, 0)   ; Encoded as 0x00000000, Expands to: mov zero, zero
}

; Utilities
#define sizeof(Begin) (pc - Begin)*2    ; Returns the data size between Begin and the current spot
#define progmem(Begin, End) #res (End - Begin)*2    ; Reserve space to fit program memory between Begin and End

; Banks
#bankdef program {
    #addr 0
    #size 0x10000   ; 64k
    #outp 0
    #bits 32
}
#bankdef data {
    #addr 0
    #size 0x10000   ; 64k
    #bits 16
}

; End ruledef
#endif
