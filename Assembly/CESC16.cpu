#ifndef _RULEDEF
#define _RULEDEF
; Include ruledef file only once

#define OS_RAM_SZ 0x100     ; 256 bytes
#define CALL_GATE_ADDR 0    ; todo

#subruledef REG {
    zero => 0x0
    sp   => 0x1
    t0   => 0x2
    t1   => 0x3
    t2   => 0x4
    t3   => 0x5
    t4   => 0x6
    v0   => 0x7
    a0   => 0x8
    a1   => 0x9
    a2   => 0xA
    s0   => 0xB
    s1   => 0xC
    s2   => 0xD
    s3   => 0xE
    s4   => 0xF
}
#subruledef ALU_OP {
    and  => 0b001
    or   => 0b010
    xor  => 0b011
    add  => 0b100
    sub  => 0b101
    addc => 0b110
    subb => 0b111
}
#subruledef JUMP {
    ; Most of the x86 jump conditions
    jmp  => 0b0000
    jz   => 0b0001
    jnz  => 0b0010
    jc   => 0b0011
    jnc  => 0b0100
    jo   => 0b0101
    jno  => 0b0110
    js   => 0b0111
    jns  => 0b1000
    jbe  => 0b1001
    ja   => 0b1010
    jl   => 0b1011
    jle  => 0b1100
    jg   => 0b1101
    jge  => 0b1110
    
    ; Macros
    je   => 0b0001   ; jz
    jne  => 0b0010   ; jnz
    jb   => 0b0011   ; jc
    jnae => 0b0011   ; jc
    jnb  => 0b0100   ; jnc
    jae  => 0b0100   ; jnc
    jna  => 0b1001   ; jbe
    jnbe => 0b1010   ; ja
    jnge => 0b1011   ; jl
    jng  => 0b1100   ; jle
    jnle => 0b1101   ; jg
    jnl  => 0b1110   ; jge
}
#subruledef PEEK_OPTIONS {
    {num: u1} => num ; 1 or 0
    Up  =>  1
    Low =>  0
    Op  =>  1
    Arg =>  0
}
#subruledef JMP_ADDR {
    #ifdef RAM_PROGRAM
        skip({Off: i16})   =>  pc+(Off+1)*2 ; Skips a number of instructions (RAM)
    #else 
        skip({Off: i16})   =>  pc+Off+1  ; Skips a number of instructions (ROM)
    #endif
    {Imm: u16}   =>   Imm
}

#ruledef INSTRUCTIONS {
    ; ALU
    mov {rD: REG}, {rA: REG} => 0x00 @ rD`4 @ rA`4 @ 0x0000
    {op: ALU_OP} {rD: REG}, {rA: REG}, {rB: REG} => 0b00000 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4

    mov {rD: REG}, {Imm: i16} => 0x08 @ rD`4 @ 0x0 @ Imm
    {op: ALU_OP} {rD: REG}, {rA: REG}, {Imm: i16} => 0b00001 @ op`3 @ rD`4 @ rA`4 @ Imm
    
    mov {rD: REG}, [{Addr: u16}] => 0x40 @ rD`4 @ 0x0 @ Addr
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{Addr: u16}] => 0b01000 @ op`3 @ rD`4 @ rA`4 @ Addr
    
    mov {rD: REG}, [{rB: REG}] => 0x48 @ rD`4 @ 0x0000 @ rB`4
    {op: ALU_OP} {rD: REG}, {rA: REG}, [{rB: REG}] => 0b01001 @ op`3 @ rD`4 @ rA`4 @ 0x000 @ rB`4

    mov {rD: REG}, [{rA: REG}+{Imm: i16}]   =>  0x50 @ rD`4 @ rA`4 @ Imm
    {op: ALU_OP} {rD: REG}, [{rA: REG}+{Imm: i16}] => 0b01010 @ op`3 @ rD`4 @ rA`4 @ Imm

    mov [{Addr: u16}], {rA: REG} => 0x600 @ rA`4 @ Addr
    {op: ALU_OP} [{Addr: u16}], {rA: REG} => 0b01100 @ op`3 @ 0x0 @ rA`4 @ Addr
    
    mov [{rA: REG}], {rB: REG} => 0x680 @ rA`4 @ 0x000 @ rB`4
    {op: ALU_OP} [{rA: REG}], {rB: REG} => 0b01101 @ op`3 @ 0x0 @ rA`4 @ 0x000 @ rB`4

    mov [{rA: REG}+{Imm: i16}], {rB: REG}   =>  0x70 @ rB`4 @ rA`4 @ Imm
    {op: ALU_OP} [{rA: REG}+{Imm: i16}], {rB: REG} => 0b01110 @ op`3 @ rB`4 @ rA`4 @ Imm
    
    sll {rD: REG}, {rA: REG}, {Imm: u4} => 0x1 @ Imm @ rD`4 @ rA`4 @ 0x0000
    srl {rD: REG}, {rA: REG}, {Imm: u4} => 0x2 @ Imm @ rD`4 @ rA`4 @ 0x0000
    sra {rD: REG}, {rA: REG}, {Imm: u4} => 0x3 @ Imm @ rD`4 @ rA`4 @ 0x0000
    
    ; Memory
    swap {rD: REG}, [{rA: REG}+{Imm: i16}]  => 0x81 @ rD`4 @ rA`4 @ Imm
    peek {rD: REG}, [{rA: REG}+{Imm: i16}], {W: PEEK_OPTIONS} => 0b1000001 @ W`1 @ rD`4 @ rA`4 @ Imm
    
    push {rB: REG}  => 0x8401000 @ rB`4
    push {Imm: i16} => 0x8501 @ Imm
    pushf           => 0x86010000

    pop  {rD: REG}  => 0x87 @ rD`4 @ 0x10000
    popf            => 0x88010000
    
    ; Jumps
    {jmp: JUMP} {rA: REG}        => 0b1100 @ jmp`4 @ 0x0 @ rA`4 @ 0x0000
    {jmp: JUMP} {Addr: JMP_ADDR} => 0b1101 @ jmp`4 @ 0x00 @ Addr`16
    
    call {rB: REG}            => 0xE001 @ 0x000 @ rB`4
    call {Addr: JMP_ADDR}     => 0xE101 @ Addr`16
    syscall {rB: REG}         => 0xE201 @ 0x000 @ rB`4
    syscall {Addr: JMP_ADDR}  => 0xE301 @ Addr`16
    enter {rB: REG}           => 0xE401 @ 0x000 @ rB`4
    enter {Addr: JMP_ADDR}    => 0xE501 @ Addr`16
    ret     => 0xE6010000
    sysret  => 0xE7010000
    exit    => 0xE8010000
}

#ruledef MACROS {
    movf {rD: REG}, {rA: REG}               => asm { add {rD}, zero, {rA} }
    movf {rD: REG}, [{Addr: u16}]           => asm { add {rD}, zero, [Addr] }
    movf {rD: REG}, {Imm: i16}              => asm { add {rD}, zero, Imm }
    movf {rD: REG}, [{rA: REG}]             => asm { add {rD}, zero, [{rA}] }
    movf {rD: REG}, [{rA: REG}+{Imm: i16}]  => asm { mov {rD}, [{rA}+Imm] } @ asm { test {rD} }
    
    not  {rD: REG}, {rA: REG}               => asm { xor {rD}, {rA}, 0xFFFF }
    nand {rD: REG}, {rA: REG}, {rB: REG}    => asm { and {rD}, {rA}, {rB} } @ asm { not {rD}, {rD} }
    nor  {rD: REG}, {rA: REG}, {rB: REG}    => asm { or {rD}, {rA}, {rB} }  @ asm { not {rD}, {rD} }
    xnor {rD: REG}, {rA: REG}, {rB: REG}    => asm { xor {rD}, {rA}, {rB} } @ asm { not {rD}, {rD} }
    sllc {rD: REG}, {rA: REG}               => asm { addc {rD}, {rA}, {rA} }
    
    swap {rA: REG}, {rB: REG}   => asm { xor {rA},{rA},{rB} } @ asm { xor {rB},{rA},{rB} } @ asm { xor {rA},{rA},{rB} }
    swap {rD: REG}, [{Imm: i16}]            => asm { swap {rD}, [zero+Imm] }
    swap {rD: REG}, [{rA: REG}]             => asm { swap {rD}, [{rA}+0] }
    peek {rD: REG}, [{Imm: i16}], {W: PEEK_OPTIONS} => asm { peek {rD}, [zero+Imm], {W} }
    peek {rD: REG}, [{rA: REG}],  {W: PEEK_OPTIONS} => asm { peek {rD}, [{rA}+0], {W} }
    
    cmp {rA: REG}, {rB: REG}                => asm { sub zero, {rA}, {rB} }
    cmp {rA: REG}, {Imm: i16}               => asm { sub zero, {rA}, Imm }
    
    mask {rA: REG}, {rB: REG}               => asm { and zero, {rA}, {rB} }
    mask {rA: REG}, {Imm: i16}              => asm { and zero, {rA}, Imm }
    mask {rA: REG}, [{Addr: u16}]           => asm { and zero, {rA}, [Addr] }
    mask {rA: REG}, [{rB: REG}]             => asm { and zero, {rA}, [{rB}] }
    
    test {rA: REG}                          => asm { movf zero, {rA} }
    test [{Addr: u16}]                      => asm { movf zero, [Addr] }
    test [{rA: REG}]                        => asm { movf zero, [{rA}] }
    test [{rA: REG}+{Imm: i16}]             => asm { add zero, [{rA}+Imm] }
    
    clrf    => asm { movf zero, 0x0001 }
    
    nop     => asm { mov zero, zero }
}

; Utilities
#ifdef RAM_PROGRAM
    #define sizeof(Begin) (pc - Begin)    ; Returns the data size between Begin and the current spot (RAM)
#else 
    #define sizeof(Begin) (pc - Begin)*2  ; Returns the data size between Begin and the current spot (ROM)
#endif

#define progmem(Begin, End) #res (End - Begin)*2    ; Reserve space to fit program memory between Begin and End
#define str(text)   #d text, "\0"       ; Remember to use "#align 32" afterwards

; Banks
#ifndef RAM_PROGRAM
; BANKS FOR OS (ROM)
#bankdef program {
    #addr 0
    #size 0x10000   ; 64k
    #outp 0
    #bits 32
}
#bankdef data {
    #addr 0
    #size 0x10000   ; 64k
    #bits 16
}

#else
; BANKS FOR USER PROGRAMS (RAM)
#bankdef program_labels {
    #addr 0
    #size 0x10000   ; 64k
    #bits 32
}
#bankdef mem {
    #addr OS_RAM_SZ ; Reserve memory for OS global variables
    #size 0x10000   ; 64k
    #bits 16
    #outp 0
}
#endif

#ifdef RAM_PROGRAM
    #include "OS/symbols.inc"
#endif

; End ruledef
#endif
